// Code generated by go-integral. DO NOT EDIT.

package seed

import (
	"context"

	"fmt"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/jmoiron/sqlx"
)

type {{ .TableName.Golang }}RecordInput struct { {{ range .RecordInputColumns }}
  {{ .Name.Golang }} {{ .GoType }}{{ end }}
}

type {{ .TableName.Golang }}Record struct { {{ range .TableColumns }}
  {{ .Name.Golang }} {{ .GoType }} `db:"{{ .Name.SQL }}"`{{ end }}
}

// Create{{ .TableName.Golang }}TableRecord is a function that creates a record from an input
func Create{{ .TableName.Golang }}TableRecord(
  input {{ .TableName.Golang }}RecordInput, {{- range $i, $value := .DependencyTables }}
  {{ $value.InputRecordName }}Model {{ $value.GolangTableName }}Record,
  {{- end }}
) {{ .TableName.Golang }}Record {
  return {{ .TableName.Golang }}Record{ {{ range $input, $output := .InputToOutputMap }}
    {{ $input }}: {{ $output.ObjectName }}.{{ $output.FieldName }},
    {{- end }}
  }
}

// Insert{{ .TableName.Golang }}TableRecord is a function that inserts a record into the database
func Insert{{ .TableName.Golang }}TableRecord(ctx context.Context, db *sqlx.DB, record {{ .TableName.Golang }}Record) error {
  query := `
    INSERT INTO {{ .TableName.SQL }} ({{- range $i, $elem := .TableColumns }}
      {{ $elem.Name.SQL }}{{ if ne (inc $i) (len $.TableColumns) }}, {{- end }}{{- end }}
    )
    VALUES ({{ range $i, $elem := .TableColumns }}${{ inc $i }}{{ if ne (inc $i) (len $.TableColumns) }},{{- end }}{{- end }})
  `
  _, err := db.ExecContext(ctx, query,{{ range .TableColumns }}
    record.{{ .Name.Golang }},{{- end }}
  )
  return err
}

// Assert{{ .TableName.Golang }}TableRecord is a function that asserts that a particular record exists in the database
func Assert{{ .TableName.Golang }}TableRecord(ctx context.Context, db *sqlx.DB, record {{ .TableName.Golang }}Record) error {
  query := `
    SELECT * FROM {{ .TableName.SQL }}
    WHERE {{ range $i, $elem := .SQLTablePrimaryKey }}{{ if ne ($i) (0) }} AND {{ end }}{{ $elem.SQL }} = ${{ inc $i }}{{- end }}
    LIMIT 1;
  `
  
  var dbRecord {{ .TableName.Golang }}Record
  err := db.GetContext(ctx, &dbRecord, query,{{ range $i, $elem := .SQLTablePrimaryKey }}
    record.{{ $elem.Golang }},{{- end }}
  )
  if err != nil {
    return err
  }
  
  // compare the records, but optionally omit checking the DateTime fields
  isEqual := cmp.Equal(dbRecord, record, cmpopts.IgnoreTypes(time.Time{}))
  if !isEqual {
    return fmt.Errorf("record does not match the database record")
  } else {
    return nil
  }
}

